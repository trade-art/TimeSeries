name: Build RedisTimeSeries Module (Windows)

on:
  push:
  workflow_dispatch:
    inputs:
      timeseries_version:
        description: "RedisTimeSeries git tag (e.g. v7.99.91)"
        required: true
        default: "v7.99.91"

jobs:
  build:
    runs-on: windows-latest

    env:
      DEFAULT_TIMESERIES_VERSION: v7.99.91

    defaults:
      run:
        shell: msys2 {0}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup MSYS2 (MINGW64)
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            autoconf
            automake
            libtool
            m4
            jq
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-make
            make
            mingw-w64-x86_64-pkg-config
            mingw-w64-x86_64-openssl
            mingw-w64-x86_64-cmake
            mingw-w64-x86_64-python
            mingw-w64-x86_64-python-pip
            git
            tar
            curl
            p7zip

      - name: Resolve RedisTimeSeries version
        id: vars
        run: |
          set -euo pipefail
          VERSION="${{ github.event.inputs.timeseries_version }}"
          if [ -z "${VERSION}" ]; then
            VERSION="${DEFAULT_TIMESERIES_VERSION}"
          fi
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Using RedisTimeSeries version: ${VERSION}"

      - name: Ensure python3 + pip commands exist
        run: |
          set -euo pipefail
          if ! command -v python3 >/dev/null 2>&1; then
            if command -v python >/dev/null 2>&1; then
              printf '%s\n' '#!/usr/bin/env bash' 'exec python "$@"' > /mingw64/bin/python3
              chmod +x /mingw64/bin/python3
            fi
          fi
          python3 --version
          python3 -m pip --version

      - name: Download RedisTimeSeries source
        run: |
          set -euo pipefail
          echo "Cloning redistimeseries ${{ steps.vars.outputs.version }}"
          git clone --recursive --depth 1 --branch "${{ steps.vars.outputs.version }}" https://github.com/redistimeseries/redistimeseries.git redistimeseries-src

      - name: Patch readies for Windows (python + Werror)
        working-directory: redistimeseries-src
        run: |
          set -euo pipefail

          # Fix readies platform detection on Windows: os.version() does not exist in Python.
          PAELLA_PLATFORM="deps/readies/paella/platform.py"
          if [ -f "$PAELLA_PLATFORM" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/readies/paella/platform.py")
          text = path.read_text(encoding="utf-8", errors="ignore")
          old = "self.os_full_ver = os.version()"
          new = "self.os_full_ver = platform.version()"
          if old in text and new not in text:
              path.write_text(text.replace(old, new), encoding="utf-8")
          PY
          fi

          # Drop readies -Werror flags that break dependency builds on Windows/MinGW.
          CC_DEFS="deps/readies/mk/cc.defs"
          if [ -f "$CC_DEFS" ]; then
            sed -i '/-Werror=incompatible-pointer-types/d' "$CC_DEFS"
            sed -i '/-Werror=implicit-function-declaration/d' "$CC_DEFS"
          fi

          # hiredis 的 libevent adapter 在 Windows 下应使用 evutil_socket_t 作为 fd 类型，避免回调签名不匹配。
          HIREDIS_LIBEVENT_H="deps/LibMR/deps/hiredis/adapters/libevent.h"
          if [ -f "$HIREDIS_LIBEVENT_H" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/LibMR/deps/hiredis/adapters/libevent.h")
          text = path.read_text(encoding="utf-8", errors="ignore")

          if "redisLibeventHandler(evutil_socket_t fd" not in text:
              text2 = text.replace(
                  "static void redisLibeventHandler(int fd, short event, void *arg) {",
                  "static void redisLibeventHandler(evutil_socket_t fd, short event, void *arg) {",
              )
              if text2 != text:
                  path.write_text(text2, encoding="utf-8")
          PY
          fi

          # LibMR 在 Windows 下应使用 libevent 的 windows threads；同时避免调用不存在的 err()。
          LIBMR_EVENT_LOOP_C="deps/LibMR/src/event_loop.c"
          if [ -f "$LIBMR_EVENT_LOOP_C" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/LibMR/src/event_loop.c")
          text = path.read_text(encoding="utf-8", errors="ignore")

          # 1) 禁止在未知平台调用 err()（Windows/MSYS2 会走到 else 分支）。
          if 'err("thread_do()' in text:
              text = text.replace(
                  '  err("thread_do(): pthread_setname_np is not supported on this system");',
                  '  /* Windows/MSYS2: 不支持 pthread_setname_np/prctl，跳过线程命名 */',
              )

          # 2) Windows 下使用 evthread_use_windows_threads；其它平台继续用 pthreads。
          if "evthread_use_pthreads();" in text and "evthread_use_windows_threads" not in text:
              text = text.replace(
                  "    evthread_use_pthreads();",
                  "#if defined(_WIN32) && !defined(__CYGWIN__)\n"
                  "    evthread_use_windows_threads();\n"
                  "#else\n"
                  "    evthread_use_pthreads();\n"
                  "#endif",
              )

          path.write_text(text, encoding="utf-8")
          PY
          fi

          # LibMR 使用 random() 获取随机数；Windows/MinGW 下用 rand() 替代（语义足够用于抽样）。
          LIBMR_DICT_C="deps/LibMR/src/utils/dict.c"
          if [ -f "$LIBMR_DICT_C" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/LibMR/src/utils/dict.c")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "random()" not in text:
              raise SystemExit(0)

          # 避免重复替换
          if "mr_random()" in text:
              raise SystemExit(0)

          newline = "\r\n" if "\r\n" in text else "\n"
          include_anchor = "#include <stdlib.h>"
          if include_anchor not in text:
              raise SystemExit("ERROR: cannot find include anchor in deps/LibMR/src/utils/dict.c")

          helper = (
              newline +
              "#if defined(_WIN32) && !defined(__CYGWIN__)" + newline +
              "static inline long mr_random(void) { return (long)rand(); }" + newline +
              "#define random mr_random" + newline +
              "#endif" + newline
          )

          text2 = text.replace(include_anchor, include_anchor + helper, 1)
          path.write_text(text2, encoding="utf-8")
          PY
          fi

          # LibMR 线程池用 POSIX signals(SIGUSR2/sigaction) 实现 pause/resume；Windows/MinGW 不支持，禁用该能力。
          LIBMR_THPOOL_C="deps/LibMR/src/utils/thpool.c"
          if [ -f "$LIBMR_THPOOL_C" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/LibMR/src/utils/thpool.c")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "SIGUSR2" not in text and "sigaction" not in text:
              raise SystemExit(0)

          newline = "\r\n" if "\r\n" in text else "\n"

          # 1) mr_thpool_pause 在 Windows 下直接返回
          if "#if defined(_WIN32)" not in text and "mr_thpool_pause" in text:
              text = text.replace(
                  "void mr_thpool_pause(mr_thpool_* thpool_p) {",
                  "void mr_thpool_pause(mr_thpool_* thpool_p) {" + newline +
                  "#if defined(_WIN32) && !defined(__CYGWIN__)" + newline +
                  "  (void)thpool_p;" + newline +
                  "  return;" + newline +
                  "#endif",
                  1
              )

          # 2) thread_do 里的 signal handler 注册在 Windows 下跳过
          marker = "  /* Register signal handler */"
          if marker in text:
              idx = text.find(marker)
              if idx != -1:
                  # 在 marker 前插入 Windows guard，marker 后追加 #endif（简单定位：在 sigaction(...) 块后）
                  if "#if defined(_WIN32) && !defined(__CYGWIN__)" not in text[idx-200:idx+200]:
                      text = text.replace(
                          marker,
                          "#if !defined(_WIN32) || defined(__CYGWIN__)" + newline + marker,
                          1,
                      )
                  # 在第一次出现 "  /* Mark thread as alive" 前插入 #endif
                  alive_marker = "  /* Mark thread as alive (initialized) */"
                  if alive_marker in text and "#endif" not in text[text.find(marker):text.find(alive_marker)]:
                      text = text.replace(
                          alive_marker,
                          "#endif" + newline + newline + alive_marker,
                          1,
                      )

          # 3) 去掉 thread name 的 err()（和 event_loop.c 一样）
          if 'err("thread_do()' in text:
              text = text.replace(
                  '  err("thread_do(): pthread_setname_np is not supported on this system");',
                  '  /* Windows/MSYS2: 不支持 pthread_setname_np/prctl，跳过线程命名 */',
              )

          path.write_text(text, encoding="utf-8")
          PY
          fi

          # MinGW/Windows 没有 POSIX 的 strsep；rmutil 使用它解析 INFO 输出，会导致编译失败。
          RMUTIL_UTIL_C="deps/RedisModulesSDK/rmutil/util.c"
          if [ -f "$RMUTIL_UTIL_C" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/RedisModulesSDK/rmutil/util.c")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "rmutil_strsep" in text:
              raise SystemExit(0)

          marker = '#include "util.h"\n'
          if marker not in text:
              raise SystemExit('ERROR: cannot find marker: #include "util.h"')

          patch_lines = [
              "#if defined(_WIN32) && !defined(__CYGWIN__)",
              "#ifndef strncasecmp",
              "#define strncasecmp _strnicmp",
              "#endif",
              "",
              "static char *rmutil_strsep(char **stringp, const char *delim) {",
              "  char *start = *stringp;",
              "  char *p;",
              "  if (start == NULL) return NULL;",
              "  p = start;",
              "  while (*p) {",
              "    const char *d = delim;",
              "    while (*d) {",
              "      if (*p == *d) {",
              "        *p = '\\\\0';",
              "        *stringp = p + 1;",
              "        return start;",
              "      }",
              "      d++;",
              "    }",
              "    p++;",
              "  }",
              "  *stringp = NULL;",
              "  return start;",
              "}",
              "#define strsep rmutil_strsep",
              "#endif",
              "",
          ]
          patch = "\n".join(patch_lines) + "\n"

          path.write_text(text.replace(marker, marker + patch, 1), encoding="utf-8")
          PY
          fi

          # CMake 4.x 移除了对 <3.5 的兼容：cpu_features 与其 googletest 下载脚本需要提升最低版本。
          CPU_FEATURES_CMAKE="deps/cpu_features/CMakeLists.txt"
          if [ -f "$CPU_FEATURES_CMAKE" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/cpu_features/CMakeLists.txt")
          text = path.read_text(encoding="utf-8", errors="ignore")
          text2 = text.replace("cmake_minimum_required(VERSION 3.0)", "cmake_minimum_required(VERSION 3.5)")
          if text2 != text:
              path.write_text(text2, encoding="utf-8")
          PY
          fi

          GTEST_DL_CMAKE="deps/cpu_features/cmake/googletest.CMakeLists.txt.in"
          if [ -f "$GTEST_DL_CMAKE" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/cpu_features/cmake/googletest.CMakeLists.txt.in")
          text = path.read_text(encoding="utf-8", errors="ignore")
          text2 = text.replace("cmake_minimum_required(VERSION 2.8.2)", "cmake_minimum_required(VERSION 3.5)")
          if text2 != text:
              path.write_text(text2, encoding="utf-8")
          PY
          fi

          # MinGW 的 <sys/param.h> 可能不提供 MAX 宏，导致被当成函数调用并触发编译错误。
          ARR_H="src/utils/arr.h"
          if [ -f "$ARR_H" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("src/utils/arr.h")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "#define MAX(" in text or "\n#ifndef MAX\n" in text:
              raise SystemExit(0)

          newline = "\r\n" if "\r\n" in text else "\n"
          lines = text.splitlines(True)
          out = []
          inserted = False
          for line in lines:
              out.append(line)
              if not inserted and line.strip() == "#include <assert.h>":
                  out.append(newline)
                  out.append("#ifndef MAX" + newline)
                  out.append("#define MAX(a,b) ((a) > (b) ? (a) : (b))" + newline)
                  out.append("#endif" + newline)
                  out.append(newline)
                  inserted = True
          if not inserted:
              raise SystemExit("ERROR: cannot find include anchor in src/utils/arr.h")

          path.write_text("".join(out), encoding="utf-8")
          PY
          fi

          # LibMR 的 utils/arr.h 同样依赖 MAX 宏：在 MinGW 下补齐。
          LIBMR_ARR_H="deps/LibMR/src/utils/arr.h"
          if [ -f "$LIBMR_ARR_H" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/LibMR/src/utils/arr.h")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "#define MAX(" in text or "\n#ifndef MAX\n" in text:
              raise SystemExit(0)

          newline = "\r\n" if "\r\n" in text else "\n"
          lines = text.splitlines(True)
          out = []
          inserted = False
          for line in lines:
              out.append(line)
              if not inserted and line.strip() == "#include <stdbool.h>":
                  out.append(newline)
                  out.append("#ifndef MAX" + newline)
                  out.append("#define MAX(a,b) ((a) > (b) ? (a) : (b))" + newline)
                  out.append("#endif" + newline)
                  out.append(newline)
                  inserted = True
          if not inserted:
              raise SystemExit("ERROR: cannot find include anchor in deps/LibMR/src/utils/arr.h")

          path.write_text("".join(out), encoding="utf-8")
          PY
          fi

          # Windows/MinGW 下可能缺少 ushort typedef，统一补齐（仅在 Windows 生效，避免影响其它平台）。
          CONSTS_H="src/consts.h"
          if [ -f "$CONSTS_H" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("src/consts.h")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "typedef unsigned short ushort;" in text:
              raise SystemExit(0)

          newline = "\r\n" if "\r\n" in text else "\n"
          lines = text.splitlines(True)
          out = []
          inserted = False
          for line in lines:
              out.append(line)
              if not inserted and line.strip() == "#include <assert.h>":
                  out.append(newline)
                  out.append("#if defined(_WIN32) && !defined(__CYGWIN__)" + newline)
                  out.append("typedef unsigned short ushort;" + newline)
                  out.append("#endif" + newline)
                  out.append(newline)
                  inserted = True
          if not inserted:
              raise SystemExit("ERROR: cannot find include anchor in src/consts.h")

          path.write_text("".join(out), encoding="utf-8")
          PY
          fi

      - name: Build RedisTimeSeries module
        working-directory: redistimeseries-src
        run: |
          set -euo pipefail
          JOBS="$(python -c 'import os; print(os.cpu_count() or 1)')"
          MAKE_BIN=make
          command -v "$MAKE_BIN" >/dev/null 2>&1 || MAKE_BIN=mingw32-make

          # readies/bin/getpy3 uses MYPY when present; enforce a working interpreter with pip.
          export MYPY=python

          # CMake 4.x 默认更倾向 Ninja；而 readies 的 cmake.rules 期望生成 Makefile 并用 make 构建。
          export CMAKE_GENERATOR="Unix Makefiles"

          # 仅需构建 libevent 库：禁用 samples / regress / openssl，避免 MinGW 下样例与回归测试编译失败。
          # 同时为了便于定位 make 返回 2 的原因，把完整输出保存到文件并在失败时打印尾部。
          LOG="${PWD}/build-windows.log"
          set +e
          "$MAKE_BIN" DISABLE_WERRORS=1 -j"$JOBS" V=1 VERBOSE=1 \
            "CONFIGURE_FLAGS.windows=--disable-samples --disable-libevent-regress --disable-openssl" \
            2>&1 | tee "$LOG"
          STATUS="${PIPESTATUS[0]}"
          set -e

          echo "make exit code: ${STATUS}"
          if [ "${STATUS}" -ne 0 ]; then
            echo "---- build log tail (last 200 lines) ----"
            tail -n 200 "$LOG" || true
            exit "${STATUS}"
          fi

      - name: Upload build log (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-windows-log
          path: redistimeseries-src/build-windows.log
          retention-days: 14

      - name: Package artifact
        run: |
          set -euo pipefail
          DIST="dist/RedisTimeSeries-${{ steps.vars.outputs.version }}-Windows-x64"
          mkdir -p "$DIST"

          TS_MOD="$(cd redistimeseries-src && find bin -maxdepth 6 -type f \( -name 'redistimeseries*.so' -o -name 'redistimeseries*.dll' \) | head -n 1)"
          if [ -z "$TS_MOD" ]; then
            echo "ERROR: module binary not found under redistimeseries-src/bin"
            exit 1
          fi

          # Provide both extensions for convenience.
          cp "$TS_MOD" "$DIST/redistimeseries.so"
          cp "$TS_MOD" "$DIST/redistimeseries.dll"

          # Copy common runtime DLLs (ignore if missing).
          cp /mingw64/bin/libgcc_s_seh-1.dll "$DIST/" || true
          cp /mingw64/bin/libstdc++-6.dll "$DIST/" || true
          cp /mingw64/bin/libwinpthread-1.dll "$DIST/" || true
          cp /mingw64/bin/libcrypto-3-x64.dll "$DIST/" || true
          cp /mingw64/bin/libssl-3-x64.dll "$DIST/" || true

          (cd dist && 7z a -tzip "RedisTimeSeries-${{ steps.vars.outputs.version }}-Windows-x64.zip" "RedisTimeSeries-${{ steps.vars.outputs.version }}-Windows-x64")

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: redistimeseries-windows
          path: dist/*.zip
          retention-days: 14
