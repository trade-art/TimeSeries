name: Build RedisTimeSeries Module (Windows)

"on":
  push: {}
  workflow_dispatch:
    inputs:
      timeseries_version:
        description: "RedisTimeSeries git tag (e.g. v7.99.91)"
        required: true
        default: "v7.99.91"

jobs:
  build:
    runs-on: windows-latest

    env:
      DEFAULT_TIMESERIES_VERSION: v7.99.91

    defaults:
      run:
        shell: 'msys2 {0}'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup MSYS2 (MINGW64)
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            autoconf
            automake
            libtool
            m4
            jq
            mingw-w64-x86_64-dlfcn
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-make
            make
            mingw-w64-x86_64-pkg-config
            mingw-w64-x86_64-openssl
            mingw-w64-x86_64-cmake
            mingw-w64-x86_64-python
            mingw-w64-x86_64-python-pip
            git
            tar
            curl
            p7zip

      - name: Resolve RedisTimeSeries version
        id: vars
        run: |
          set -euo pipefail
          VERSION="${{ github.event.inputs.timeseries_version }}"
          if [ -z "${VERSION}" ]; then
            VERSION="${DEFAULT_TIMESERIES_VERSION}"
          fi
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Using RedisTimeSeries version: ${VERSION}"

      - name: Ensure python3 + pip commands exist
        run: |
          set -euo pipefail
          if ! command -v python3 >/dev/null 2>&1; then
            if command -v python >/dev/null 2>&1; then
              printf '%s\n' '#!/usr/bin/env bash' 'exec python "$@"' > /mingw64/bin/python3
              chmod +x /mingw64/bin/python3
            fi
          fi
          python3 --version
          python3 -m pip --version

      - name: Download RedisTimeSeries source
        run: |
          set -euo pipefail
          echo "Cloning redistimeseries ${{ steps.vars.outputs.version }}"
          git clone --recursive --depth 1 --branch "${{ steps.vars.outputs.version }}" https://github.com/redistimeseries/redistimeseries.git redistimeseries-src

      - name: Patch readies for Windows (python + Werror)
        working-directory: redistimeseries-src
        run: |
          set -euo pipefail

          # Fix readies platform detection on Windows: os.version() does not exist in Python.
          PAELLA_PLATFORM="deps/readies/paella/platform.py"
          if [ -f "$PAELLA_PLATFORM" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/readies/paella/platform.py")
          text = path.read_text(encoding="utf-8", errors="ignore")
          old = "self.os_full_ver = os.version()"
          new = "self.os_full_ver = platform.version()"
          if old in text and new not in text:
              path.write_text(text.replace(old, new), encoding="utf-8")
          PY
          fi

          # Drop readies -Werror flags that break dependency builds on Windows/MinGW.
          CC_DEFS="deps/readies/mk/cc.defs"
          if [ -f "$CC_DEFS" ]; then
            sed -i '/-Werror=incompatible-pointer-types/d' "$CC_DEFS"
            sed -i '/-Werror=implicit-function-declaration/d' "$CC_DEFS"
          fi

          # hiredis Ã§Å¡?libevent adapter Ã¥Å“?Windows Ã¤Â¸â€¹Ã¥Âºâ€Ã¤Â½Â¿Ã§â€?evutil_socket_t Ã¤Â½Å“Ã¤Â¸Âº fd Ã§Â±Â»Ã¥Å¾â€¹Ã¯Â¼Å’Ã©Â¿Ã¥â€¦Ã¥â€ºÅ¾Ã¨Â°Æ’Ã§Â­Â¾Ã¥Ã¤Â¸Ã¥Å’Â¹Ã©â€¦Ã£â‚¬?
          HIREDIS_LIBEVENT_H="deps/LibMR/deps/hiredis/adapters/libevent.h"
          if [ -f "$HIREDIS_LIBEVENT_H" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/LibMR/deps/hiredis/adapters/libevent.h")
          text = path.read_text(encoding="utf-8", errors="ignore")

          if "redisLibeventHandler(evutil_socket_t fd" not in text:
              text2 = text.replace(
                  "static void redisLibeventHandler(int fd, short event, void *arg) {",
                  "static void redisLibeventHandler(evutil_socket_t fd, short event, void *arg) {",
              )
              if text2 != text:
                  path.write_text(text2, encoding="utf-8")
          PY
          fi

          # LibMR Ã¥Å“?Windows Ã¤Â¸â€¹Ã¥Âºâ€Ã¤Â½Â¿Ã§â€?libevent Ã§Å¡?windows threadsÃ¯Â¼â€ºÃ¥Å’Ã¦â€”Â¶Ã©Â¿Ã¥â€¦Ã¨Â°Æ’Ã§â€Â¨Ã¤Â¸Ã¥Â­ËœÃ¥Å“Â¨Ã?err()Ã£?
          LIBMR_EVENT_LOOP_C="deps/LibMR/src/event_loop.c"
          if [ -f "$LIBMR_EVENT_LOOP_C" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/LibMR/src/event_loop.c")
          text = path.read_text(encoding="utf-8", errors="ignore")

          # 1) Ã§Â¦Ã¦Â­Â¢Ã¥Å“Â¨Ã¦Å“ÂªÃ§Å¸Â¥Ã¥Â¹Â³Ã¥Â°Ã¨Â°Æ’Ã§?err()Ã¯Â¼Ë†Windows/MSYS2 Ã¤Â¼Å¡Ã¨ÂµÂ°Ã¥Ë†?else Ã¥Ë†â€ Ã¦â€Â¯Ã¯Â¼â€°Ã£â‚¬?
          if 'err("thread_do()' in text:
              text = text.replace(
                  '  err("thread_do(): pthread_setname_np is not supported on this system");',
                  '  /* Windows/MSYS2: Ã¤Â¸Ã¦â€Â¯Ã?pthread_setname_np/prctlÃ¯Â¼Å’Ã¨Â·Â³Ã¨Â¿â€¡Ã§ÂºÂ¿Ã§Â¨â€¹Ã¥â€˜Â½Ã?*/',
              )

          # 2) Windows Ã¤Â¸â€¹Ã¤Â½Â¿Ã?evthread_use_windows_threadsÃ¯Â¼â€ºÃ¥â€¦Â¶Ã¥Â®Æ’Ã¥Â¹Â³Ã¥Â°Ã§Â»Â§Ã§Â»Â­Ã§â€?pthreadsÃ£?
          if "evthread_use_pthreads();" in text and "evthread_use_windows_threads" not in text:
              text = text.replace(
                  "    evthread_use_pthreads();",
                  "#if defined(_WIN32) && !defined(__CYGWIN__)\n"
                  "    evthread_use_windows_threads();\n"
                  "#else\n"
                  "    evthread_use_pthreads();\n"
                  "#endif",
              )

          path.write_text(text, encoding="utf-8")
          PY
          fi

          # LibMR Ã¤Â½Â¿Ã§â€?random() Ã¨Å½Â·Ã¥â€“Ã©Å¡Ã¦Å“ÂºÃ¦â€¢Â°Ã¯Â¼â€ºWindows/MinGW Ã¤Â¸â€¹Ã§â€?rand() Ã¦â€ºÂ¿Ã¤Â»Â£Ã¯Â¼Ë†Ã¨Â¯Â­Ã¤Â¹â€°Ã¨Â¶Â³Ã¥Â¤Å¸Ã§â€Â¨Ã¤ÂºÅ½Ã¦Å Â½Ã¦Â Â·Ã¯Â¼â€°Ã£â‚¬?
          LIBMR_DICT_C="deps/LibMR/src/utils/dict.c"
          if [ -f "$LIBMR_DICT_C" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/LibMR/src/utils/dict.c")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "random()" not in text:
              raise SystemExit(0)

          # Ã©Â¿Ã¥â€¦Ã©â€¡Ã¥Â¤Ã¦â€ºÂ¿Ã?
          if "mr_random()" in text:
              raise SystemExit(0)

          newline = "\r\n" if "\r\n" in text else "\n"
          include_anchor = "#include <stdlib.h>"
          if include_anchor not in text:
              raise SystemExit("ERROR: cannot find include anchor in deps/LibMR/src/utils/dict.c")

          helper = (
              newline +
              "#if defined(_WIN32) && !defined(__CYGWIN__)" + newline +
              "static inline long mr_random(void) { return (long)rand(); }" + newline +
              "#define random mr_random" + newline +
              "#endif" + newline
          )

          text2 = text.replace(include_anchor, include_anchor + helper, 1)
          path.write_text(text2, encoding="utf-8")
          PY
          fi

          # LibMR Ã§ÂºÂ¿Ã§Â¨â€¹Ã¦Â±Â Ã§â€?POSIX signals(SIGUSR2/sigaction) Ã¥Â®Å¾Ã§Å½Â° pause/resumeÃ¯Â¼â€ºWindows/MinGW Ã¤Â¸Ã¦â€Â¯Ã¦Å’Ã¯Â¼Å’Ã§Â¦Ã§â€Â¨Ã¨Â¯Â¥Ã¨Æ’Â½Ã¥Å â€ºÃ£â‚¬?
          LIBMR_THPOOL_C="deps/LibMR/src/utils/thpool.c"
          if [ -f "$LIBMR_THPOOL_C" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/LibMR/src/utils/thpool.c")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "SIGUSR2" not in text and "sigaction" not in text:
              raise SystemExit(0)

          newline = "\r\n" if "\r\n" in text else "\n"

          # 1) mr_thpool_pause: Windows Ã¤Â¸â€¹Ã§Â¦Ã?SIGUSR2Ã¯Â¼Ë†Ã§â€Â¨Ã©Â¢â€Ã¥Â¤â€Ã§â€ Ã¥â€°â€Ã©â„¢Â¤Ã¯Â¼â€°Ã¯Â¼Å’Ã?Windows Ã§Â»Â´Ã¦Å’Ã¥Å½Å¸Ã©â‚¬Â»Ã¨Â?
          sig = "void mr_thpool_pause(mr_thpool_* thpool_p)"
          start = text.find(sig)
          if start != -1:
              brace = text.find("{", start)
              if brace == -1:
                  raise SystemExit("ERROR: cannot find '{' for mr_thpool_pause")
              depth = 0
              end = None
              for i in range(brace, len(text)):
                  c = text[i]
                  if c == "{":
                      depth += 1
                  elif c == "}":
                      depth -= 1
                      if depth == 0:
                          end = i
                          break
              if end is None:
                  raise SystemExit("ERROR: cannot find end of mr_thpool_pause")

              body = text[brace + 1 : end].strip()
              if "SIGUSR2" in body and "#if defined(_WIN32)" not in body:
                  replacement = (
                      sig + " {" + newline +
                      "#if defined(_WIN32) && !defined(__CYGWIN__)" + newline +
                      "  (void)thpool_p;" + newline +
                      "  return;" + newline +
                      "#else" + newline +
                      body + newline +
                      "#endif" + newline +
                      "}"
                  )
                  text = text[:start] + replacement + text[end + 1 :]

          # 2) thread_do Ã©â€¡Å’Ã§Å?signal handler Ã¦Â³Â¨Ã¥â€ Å’Ã?Windows Ã¤Â¸â€¹Ã¨Â·Â³Ã?
          marker = "  /* Register signal handler */"
          if marker in text:
              idx = text.find(marker)
              if idx != -1:
                  # Ã¥Å“?marker Ã¥â€°Ã¦â€™Ã?Windows guardÃ¯Â¼Å’marker Ã¥Å½Ã¨Â¿Â½Ã¥Å ?#endifÃ¯Â¼Ë†Ã§Â®â‚¬Ã¥â€¢Ã¥Â®Å¡Ã¤Â½Ã¯Â¼Å¡Ã?sigaction(...) Ã¥â€”Ã¥Å½Ã?
                  if "#if defined(_WIN32) && !defined(__CYGWIN__)" not in text[idx-200:idx+200]:
                      text = text.replace(
                          marker,
                          "#if !defined(_WIN32) || defined(__CYGWIN__)" + newline + marker,
                          1,
                      )
                  # Ã¥Å“Â¨Ã§Â¬Â¬Ã¤Â¸â‚¬Ã¦Â¬Â¡Ã¥â€¡ÂºÃ?"  /* Mark thread as alive" Ã¥â€°Ã¦â€™Ã?#endif
                  alive_marker = "  /* Mark thread as alive (initialized) */"
                  if alive_marker in text and "#endif" not in text[text.find(marker):text.find(alive_marker)]:
                      text = text.replace(
                          alive_marker,
                          "#endif" + newline + newline + alive_marker,
                          1,
                      )

          # 3) Ã¥Å½Â»Ã¦Å½?thread name Ã§Å¡?err()Ã¯Â¼Ë†Ã¥â€?event_loop.c Ã¤Â¸â‚¬Ã¦Â Â·Ã¯Â?
          if 'err("thread_do()' in text:
              text = text.replace(
                  '  err("thread_do(): pthread_setname_np is not supported on this system");',
                  '  /* Windows/MSYS2: Ã¤Â¸Ã¦â€Â¯Ã?pthread_setname_np/prctlÃ¯Â¼Å’Ã¨Â·Â³Ã¨Â¿â€¡Ã§ÂºÂ¿Ã§Â¨â€¹Ã¥â€˜Â½Ã?*/',
              )

          path.write_text(text, encoding="utf-8")
          PY
          fi

          # MinGW/Windows Ã¦Â²Â¡Ã¦Å“?POSIX Ã§Å¡?strsepÃ¯Â¼â€ºrmutil Ã¤Â½Â¿Ã§â€Â¨Ã¥Â®Æ’Ã¨Â§Â£Ã?INFO Ã¨Â¾â€œÃ¥â€¡ÂºÃ¯Â¼Å’Ã¤Â¼Å¡Ã¥Â¯Â¼Ã¨â€¡Â´Ã§Â¼â€“Ã¨Â¯â€˜Ã¥Â¤Â±Ã¨Â´Â¥Ã£â‚¬?
          RMUTIL_UTIL_C="deps/RedisModulesSDK/rmutil/util.c"
          if [ -f "$RMUTIL_UTIL_C" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/RedisModulesSDK/rmutil/util.c")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "rmutil_strsep" in text:
              raise SystemExit(0)

          marker = '#include "util.h"\n'
          if marker not in text:
              raise SystemExit('ERROR: cannot find marker: #include "util.h"')

          patch_lines = [
              "#if defined(_WIN32) && !defined(__CYGWIN__)",
              "#ifndef strncasecmp",
              "#define strncasecmp _strnicmp",
              "#endif",
              "",
              "static char *rmutil_strsep(char **stringp, const char *delim) {",
              "  char *start = *stringp;",
              "  char *p;",
              "  if (start == NULL) return NULL;",
              "  p = start;",
              "  while (*p) {",
              "    const char *d = delim;",
              "    while (*d) {",
              "      if (*p == *d) {",
              "        *p = '\\\\0';",
              "        *stringp = p + 1;",
              "        return start;",
              "      }",
              "      d++;",
              "    }",
              "    p++;",
              "  }",
              "  *stringp = NULL;",
              "  return start;",
              "}",
              "#define strsep rmutil_strsep",
              "#endif",
              "",
          ]
          patch = "\n".join(patch_lines) + "\n"

          path.write_text(text.replace(marker, marker + patch, 1), encoding="utf-8")
          PY
          fi

          # CMake 4.x Ã§Â§Â»Ã©â„¢Â¤Ã¤Âºâ€ Ã¥Â?<3.5 Ã§Å¡â€Ã¥â€¦Â¼Ã¥Â®Â¹Ã¯Â¼Å¡cpu_features Ã¤Â¸Å½Ã¥â€?googletest Ã¤Â¸â€¹Ã¨Â½Â½Ã¨â€Å¡Ã¦Å“Â¬Ã©Å“â‚¬Ã¨Â¦Ã¦Ã¥â€¡Ã¦Å“â‚¬Ã¤Â½Å½Ã§â€°Ë†Ã¦Å“Â¬Ã£â‚¬?
          CPU_FEATURES_CMAKE="deps/cpu_features/CMakeLists.txt"
          if [ -f "$CPU_FEATURES_CMAKE" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/cpu_features/CMakeLists.txt")
          text = path.read_text(encoding="utf-8", errors="ignore")
          text2 = text.replace("cmake_minimum_required(VERSION 3.0)", "cmake_minimum_required(VERSION 3.5)")
          if text2 != text:
              path.write_text(text2, encoding="utf-8")
          PY
          fi

          GTEST_DL_CMAKE="deps/cpu_features/cmake/googletest.CMakeLists.txt.in"
          if [ -f "$GTEST_DL_CMAKE" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/cpu_features/cmake/googletest.CMakeLists.txt.in")
          text = path.read_text(encoding="utf-8", errors="ignore")
          text2 = text.replace("cmake_minimum_required(VERSION 2.8.2)", "cmake_minimum_required(VERSION 3.5)")
          if text2 != text:
              path.write_text(text2, encoding="utf-8")
          PY
          fi

          # MinGW Ã§Å¡?<sys/param.h> Ã¥Â¯Ã¨Æ’Â½Ã¤Â¸Ã¦Ã¤Â¾?MAX Ã¥Â®Ã¯Â¼Å’Ã¥Â¯Â¼Ã¨â€¡Â´Ã¨Â¢Â«Ã¥Â½â€œÃ¦Ë†Ã¥â€¡Â½Ã¦â€¢Â°Ã¨Â°Æ’Ã§â€Â¨Ã¥Â¹Â¶Ã¨Â§Â¦Ã¥â€˜Ã§Â¼â€“Ã¨Â¯â€˜Ã©â€â„¢Ã¨Â¯Â¯Ã£?
          ARR_H="src/utils/arr.h"
          if [ -f "$ARR_H" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("src/utils/arr.h")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "#define MAX(" in text or "\n#ifndef MAX\n" in text:
              raise SystemExit(0)

          newline = "\r\n" if "\r\n" in text else "\n"
          lines = text.splitlines(True)
          out = []
          inserted = False
          for line in lines:
              out.append(line)
              if not inserted and line.strip() == "#include <assert.h>":
                  out.append(newline)
                  out.append("#ifndef MAX" + newline)
                  out.append("#define MAX(a,b) ((a) > (b) ? (a) : (b))" + newline)
                  out.append("#endif" + newline)
                  out.append(newline)
                  inserted = True
          if not inserted:
              raise SystemExit("ERROR: cannot find include anchor in src/utils/arr.h")

          path.write_text("".join(out), encoding="utf-8")
          PY
          fi

          # LibMR Ã§Å¡?utils/arr.h Ã¥Å’Ã¦Â Â·Ã¤Â¾Ã¨Âµ?MAX Ã¥Â®Ã¯Â¼Å¡Ã¥Å“?MinGW Ã¤Â¸â€¹Ã¨Â¡Â¥Ã©Â½Ã£â‚¬?
          LIBMR_ARR_H="deps/LibMR/src/utils/arr.h"
          if [ -f "$LIBMR_ARR_H" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("deps/LibMR/src/utils/arr.h")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "#define MAX(" in text or "\n#ifndef MAX\n" in text:
              raise SystemExit(0)

          newline = "\r\n" if "\r\n" in text else "\n"
          lines = text.splitlines(True)
          out = []
          inserted = False
          for line in lines:
              out.append(line)
              if not inserted and line.strip() == "#include <stdbool.h>":
                  out.append(newline)
                  out.append("#ifndef MAX" + newline)
                  out.append("#define MAX(a,b) ((a) > (b) ? (a) : (b))" + newline)
                  out.append("#endif" + newline)
                  out.append(newline)
                  inserted = True
          if not inserted:
              raise SystemExit("ERROR: cannot find include anchor in deps/LibMR/src/utils/arr.h")

          path.write_text("".join(out), encoding="utf-8")
          PY
          fi

          # Windows/MinGW Ã¤Â¸â€¹Ã¥Â¯Ã¨Æ’Â½Ã§Â¼ÂºÃ?ushort typedefÃ¯Â¼Å’Ã§Â»Å¸Ã¤Â¸â‚¬Ã¨Â¡Â¥Ã©Â½Ã¯Â¼Ë†Ã¤Â»â€¦Ã?Windows Ã§â€Å¸Ã¦â€¢Ë†Ã¯Â¼Å’Ã©Â¿Ã¥â€¦Ã¥Â½Â±Ã¥â€œÃ¥â€¦Â¶Ã¥Â®Æ’Ã¥Â¹Â³Ã¥Â°Ã¯Â¼â€°Ã£â‚¬?
          CONSTS_H="src/consts.h"
          if [ -f "$CONSTS_H" ]; then
          python - <<'PY'
          from pathlib import Path

          path = Path("src/consts.h")
          text = path.read_text(encoding="utf-8", errors="ignore")
          if "typedef unsigned short ushort;" in text:
              raise SystemExit(0)

          newline = "\r\n" if "\r\n" in text else "\n"
          lines = text.splitlines(True)
          out = []
          inserted = False
          for line in lines:
              out.append(line)
              if not inserted and line.strip() == "#include <assert.h>":
                  out.append(newline)
                  out.append("#if defined(_WIN32) && !defined(__CYGWIN__)" + newline)
                  out.append("typedef unsigned short ushort;" + newline)
                  out.append("#endif" + newline)
                  out.append(newline)
                  inserted = True
          if not inserted:
              raise SystemExit("ERROR: cannot find include anchor in src/consts.h")

          path.write_text("".join(out), encoding="utf-8")
          PY
          fi

      - name: Patch LibMR thpool for Windows (disable SIGUSR2)
        working-directory: redistimeseries-src
        run: |
          set -euo pipefail
          THPOOL="deps/LibMR/src/utils/thpool.c"
          if [ -f "$THPOOL" ]; then
          python - <<'PY'
          from __future__ import annotations

          from pathlib import Path

          path = Path("deps/LibMR/src/utils/thpool.c")
          original = path.read_text(encoding="utf-8", errors="ignore")

          if "SIGUSR2" not in original:
              raise SystemExit(0)

          if "CODEX_SIGUSR2_GUARD_BEGIN" in original:
              raise SystemExit(0)

          nl = "\r\n" if "\r\n" in original else "\n"
          lines = original.splitlines(True)
          out: list[str] = []
          i = 0

          def wrap_statement(start_idx: int) -> tuple[list[str], int]:
              stmt: list[str] = []
              j = start_idx
              while True:
                  stmt.append(lines[j])
                  if ";" in lines[j]:
                      break
                  if j >= len(lines) - 1:
                      break
                  j += 1
                  if len(stmt) > 120:
                      break
              return stmt, j

          while i < len(lines):
              line = lines[i]
              stripped = line.lstrip()

              if (
                  "SIGUSR2" in line
                  and not stripped.startswith("#")
                  and not stripped.startswith("//")
                  and not stripped.startswith("/*")
                  and not stripped.startswith("*")
              ):
                  # Ã¥ÂªÃ¥Â¤â€Ã§â€ Ã¨Â¯Â­Ã¥Â¥Ã§ÂºÂ§Ã§â€Â¨Ã¦Â³â€¢Ã¯Â¼Ë†Ã¤Â?';' Ã§Â»â€œÃ¦Å¸Ã¯Â¼â€°Ã£â‚¬â€šÃ©â€¡Ã?switch/case Ã¦â€”Â¶Ã¥ÂªÃ¥Å¡Ã¦Å“â‚¬Ã¥Â°Ã¥Å’â€¦Ã¨Â£Â¹Ã¯Â¼Å’Ã©Â¿Ã¥â€¦Ã¨Â¯Â¯Ã¤Â¼Â¤Ã£â‚¬?
                  if stripped.startswith("case ") and ":" in line:
                      out.append(f"#if !defined(_WIN32) || defined(__CYGWIN__) /* CODEX_SIGUSR2_GUARD_BEGIN */{nl}")
                      out.append(line)
                      out.append(f"#endif /* CODEX_SIGUSR2_GUARD_END */{nl}")
                      i += 1
                      continue

                  stmt, j = wrap_statement(i)
                  out.append(f"#if !defined(_WIN32) || defined(__CYGWIN__) /* CODEX_SIGUSR2_GUARD_BEGIN */{nl}")
                  out.extend(stmt)
                  out.append(f"#else{nl}(void)0;{nl}#endif /* CODEX_SIGUSR2_GUARD_END */{nl}")
                  i = j + 1
                  continue

              out.append(line)
              i += 1

          patched = "".join(out)
          if patched != original:
              path.write_text(patched, encoding="utf-8")
          PY
          fi

      - name: Patch RedisTimeSeries Makefile link flags (Windows)
        working-directory: redistimeseries-src
        run: |
          set -euo pipefail
          if [ -f "Makefile" ]; then
          python - <<'PY'
          from __future__ import annotations

          import re
          from pathlib import Path

          path = Path("Makefile")
          original = path.read_text(encoding="utf-8", errors="ignore")
          text = original

          # 1) Windows Ã¤Â¸?libevent Ã©â‚¬Å¡Ã¥Â¸Â¸Ã¤Â¸Ã¤Â¼Å¡Ã§â€Å¸Ã¦Ë?libevent_pthreads.aÃ¯Â¼â€ºÃ¤Â¸Å Ã?Makefile Ã¨â€¹Â¥Ã§Â¡Â¬Ã§Â¼â€“Ã§Â Ã¥Â®Æ’Ã¤Â¼Å¡Ã¥Â¯Â¼Ã¨â€¡Â´Ã©â€œÂ¾Ã¦Å½Â¥Ã¥Â¤Â±Ã¨Â´Â¥Ã£â‚¬?          #    Ã§â€ºÂ´Ã¦Å½Â¥Ã¦â€Â¹Ã¤Â¸ÂºÃ©â€œÂ¾Ã¦Å?libevent.aÃ¯Â¼Ë†Ã¥Å’Ã§â€ºÂ®Ã¥Â½â€¢Ã¤Â¸â€¹Ã§Å?.libs/libevent.aÃ¯Â¼â€°Ã£â‚¬?
          text = text.replace("libevent_pthreads.a", "libevent.a")
          # Ã¤Â¸â‚¬Ã¤Âºâ€ºÃ¨Â§â€Ã¥Ë†â„¢Ã¤Â¼Å¡Ã§?$(LIBEXT)/${LIBEXT} Ã¦â€¹Â¼Ã¦Å½Â¥Ã¥Å½Ã§Â¼â‚¬Ã¯Â¼Å’Ã¤Â¹Å¸Ã©Å“â‚¬Ã¨Â¦Ã¤Â¸â‚¬Ã¥Â¹Â¶Ã¤Â¿Â®Ã¦Â­?
          text = text.replace("libevent_pthreads.$(LIBEXT)", "libevent.$(LIBEXT)")
          text = text.replace("libevent_pthreads.${LIBEXT}", "libevent.${LIBEXT}")
          # Ã¦â€ºÂ´Ã¤Â¿Ã¥Â®Ë†Ã¤Â½â€ Ã¦â€ºÂ´Ã§Â¨Â³Ã¯Â¼Å¡Ã¦Å?Makefile Ã¥â€ â€¦Ã§Å?libevent_pthreads Ã§Â»Å¸Ã§Â»Å¸Ã¦â€Â¹Ã¤Â?libeventÃ¯Â¼Ë†Windows Ã¤Â¸Å Ã¨ÂµÂ° win32 threadsÃ¯Â¼?
          text = text.replace("libevent_pthreads", "libevent")

          # 2) Ã¤Â¿Â®Ã¨Â¡Â¥ redistimeseries.so Ã§Å¡â€Ã©â€œÂ¾Ã¦Å½Â¥Ã¥â€˜Â½Ã¤Â»Â¤Ã¯Â¼Å¡Ã§Â¡Â®Ã¤Â¿Ã¦ËœÂ¯Ã¥â€¦Â±Ã¤ÂºÂ«Ã¥Â?-shared) + Ã¨Â¡Â¥Ã©Â½ winsock/iphlpapi Ã¤Â¾Ã¨Âµâ€“Ã¥Âºâ€œÃ£â‚¬?
          lines = text.splitlines(True)
          # Ã¥Å’Â¹Ã©â€¦Ã§â€ºÂ®Ã¦Â â€¡Ã¨Â¡Å’Ã¯Â?..redistimeseries.so: ...
          target_re = re.compile(r"^[^#\n]*redistimeseries\.so\s*:\s*.*$")

          def patch_link_line(line: str) -> str:
              if line.lstrip().startswith(("@echo", "echo ")):
                  return line

              patched = line

              # Ã©Â¿Ã¥â€¦Ã¨Â¢Â«Ã¥Â½â€œÃ?exe Ã©â€œÂ¾Ã¦Å½Â¥Ã¯Â¼Ë†Ã¥Â¦Ã¥Ë†â„¢Ã¤Â¼Å¡Ã¥â€¡ÂºÃ§Å?WinMainÃ¯Â¼?
              if "redistimeseries.so" in patched and "-o" in patched and "-shared" not in patched:
                  patched = patched.replace("-o", "-shared -o", 1)

              # Ã¨Â¡Â¥Ã©Â½ Windows socket/Ã§Â½â€˜Ã§Â»Å“Ã¤Â¾Ã¨Âµâ€“Ã¯Â¼Å¡hiredis/libevent Ã©Æ’Â½Ã¤Â¼Å¡Ã§â€Â¨Ã¥Ë?
              if ("redistimeseries.so" in patched or "hiredis" in patched or "libevent" in patched) and "-lws2_32" not in patched:
                  extra = " -lws2_32 -liphlpapi -ladvapi32 -lshell32"
                  if patched.rstrip().endswith("\\"):
                      patched = patched.rstrip()[:-1] + extra + " \\\n"
                  else:
                      patched = patched.rstrip("\n") + extra + "\n"

              return patched

          i = 0
          while i < len(lines):
              if target_re.match(lines[i]):
                  # recipe Ã©â‚¬Å¡Ã¥Â¸Â¸Ã¦ËœÂ¯Ã¦Å½Â¥Ã¤Â¸â€¹Ã¦Â¥Ã?TAB Ã¥Â¼â‚¬Ã¥Â¤Â´Ã§Å¡â€Ã¥Â¤Å¡Ã¨Â¡Å’Ã¯Â¼â€ºÃ§â€ºÂ´Ã¥Ë†Â°Ã¤Â¸â€¹Ã¤Â¸â‚¬Ã¤Â¸ÂªÃ¢â‚¬Å“Ã¨Â§â€Ã¥Ë†â„¢Ã¨Â¡Å’Ã¢â‚¬Ã¦Ë†â€“Ã¦â€“â€¡Ã¤Â»Â¶Ã§Â»â€œÃ¦Å¸Ã£â‚¬?
                  j = i + 1
                  while j < len(lines):
                      if lines[j].startswith("\t"):
                          lines[j] = patch_link_line(lines[j])
                          j += 1
                          continue
                      if re.match(r"^[^\s#].*:\s*.*$", lines[j]):
                          break
                      j += 1
                  break
              i += 1

          patched_text = "".join(lines)
          if patched_text != original:
              path.write_text(patched_text, encoding="utf-8")
          PY
          fi

      - name: Build RedisTimeSeries module
        working-directory: redistimeseries-src
        run: |
          set -euo pipefail
          JOBS="$(python -c 'import os; print(os.cpu_count() or 1)')"
          MAKE_BIN=make
          command -v "$MAKE_BIN" >/dev/null 2>&1 || MAKE_BIN=mingw32-make

          # readies/bin/getpy3 uses MYPY when present; enforce a working interpreter with pip.
          export MYPY=python

          # CMake 4.x Ã©Â»ËœÃ¨Â®Â¤Ã¦â€ºÂ´Ã¥â‚¬Â¾Ã¥?NinjaÃ¯Â¼â€ºÃ¨â‚¬?readies Ã§Å¡?cmake.rules Ã¦Å“Å¸Ã¦Å“â€ºÃ§â€Å¸Ã¦Ë?Makefile Ã¥Â¹Â¶Ã§â€?make Ã¦Å¾â€Ã¥Â»ÂºÃ£â‚¬?          export CMAKE_GENERATOR="Unix Makefiles"

          # Ã¤Â»â€¦Ã©Å“â‚¬Ã¦Å¾â€Ã¥Â?libevent Ã¥Âºâ€œÃ¯Â¼Å¡Ã§Â¦Ã§â€?samples / regress / opensslÃ¯Â¼Å’Ã©Â¿Ã¥?MinGW Ã¤Â¸â€¹Ã¦Â Â·Ã¤Â¾â€¹Ã¤Â¸Å½Ã¥â€ºÅ¾Ã¥Â½â€™Ã¦Âµâ€¹Ã¨Â¯â€¢Ã§Â¼â€“Ã¨Â¯â€˜Ã¥Â¤Â±Ã¨Â´Â¥Ã£â‚¬?          # Ã¥Å’Ã¦â€”Â¶Ã¤Â¸ÂºÃ¤Âºâ€ Ã¤Â¾Â¿Ã¤ÂºÅ½Ã¥Â®Å¡Ã¤Â?make Ã¨Â¿â€Ã¥â€?2 Ã§Å¡â€Ã¥Å½Å¸Ã¥â€ºÂ Ã¯Â¼Å’Ã¦Å Å Ã¥Â®Å’Ã¦â€¢Â´Ã¨Â¾â€œÃ¥â€¡ÂºÃ¤Â¿Ã¥Â­ËœÃ¥Ë†Â°Ã¦â€“â€¡Ã¤Â»Â¶Ã¥Â¹Â¶Ã¥Å“Â¨Ã¥Â¤Â±Ã¨Â´Â¥Ã¦â€”Â¶Ã¦â€°â€œÃ¥Â°Ã¥Â°Â¾Ã©Æ’Â¨Ã£â‚¬?
          LOG="${PWD}/build-windows.log"
          # MinGW: autotools may add -lc/-ldl; provide aliases if missing.
          if [ ! -f /mingw64/lib/libc.a ] && [ -f /mingw64/lib/libmsvcrt.a ]; then
            cp /mingw64/lib/libmsvcrt.a /mingw64/lib/libc.a || true
          fi
          if [ ! -f /mingw64/lib/libdl.a ] && [ -f /mingw64/lib/libdlfcn.a ]; then
            cp /mingw64/lib/libdlfcn.a /mingw64/lib/libdl.a || true
          fi

          : > "$LOG"
          echo "CODEX: start make (windows) $(date -Iseconds)" >> "$LOG"

          set +e
          "$MAKE_BIN" DISABLE_WERRORS=1 -j"$JOBS" V=1 VERBOSE=1 \
            "CONFIGURE_FLAGS.windows=--disable-samples --disable-libevent-regress --disable-openssl" \
            >> "$LOG" 2>&1
          STATUS="$?"
          set -e

          # libevent on Windows may not produce libevent_pthreads.a, but upper layers can hard-link it.
          # Always apply fixups when make fails (or log mentions libevent_pthreads.a), then rerun make once.
          if [ "${STATUS}" -ne 0 ] || grep -Fq "libevent_pthreads.a" "$LOG"; then
            echo "CODEX: detected missing libevent_pthreads.a; applying link fixups and rerunning make" >> "$LOG"

            # Create a libevent_pthreads.a alias by copying libevent.a (libevent uses Windows threads on MinGW).
            LIBEVENT_A="$(find bin -path '*/libevent/.libs/libevent.a' -print -quit 2>/dev/null || true)"
            if [ -n "$LIBEVENT_A" ]; then
              LIBEVENT_DIR="${LIBEVENT_A%/libevent.a}"
              if [ ! -f "${LIBEVENT_DIR}/libevent_pthreads.a" ]; then
                cp "$LIBEVENT_A" "${LIBEVENT_DIR}/libevent_pthreads.a" || true
                echo "CODEX: created ${LIBEVENT_DIR}/libevent_pthreads.a (copied from libevent.a)" >> "$LOG"
              fi
            else
              echo "CODEX: WARN could not locate libevent.a under bin/**/libevent/.libs" >> "$LOG"
            fi

            # Patch generated makefiles under bin/ to avoid hard-linking libevent_pthreads and to add Win libs.
            python - <<'PY'
            from __future__ import annotations

            from pathlib import Path

            root = Path("bin")
            if not root.exists():
                raise SystemExit(0)

            extra_libs = " -lws2_32 -liphlpapi -ladvapi32 -lshell32"
            made_changes = False

            for path in root.rglob("*"):
                if not path.is_file():
                    continue
                if path.name != "Makefile" and not path.name.endswith(".mk"):
                    continue

                text = path.read_text(encoding="utf-8", errors="ignore")
                new = text
                new = new.replace("libevent_pthreads.a", "libevent.a")
                new = new.replace("libevent_pthreads.$(LIBEXT)", "libevent.$(LIBEXT)")
                new = new.replace("libevent_pthreads.${LIBEXT}", "libevent.${LIBEXT}")
                new = new.replace("libevent_pthreads", "libevent")

                # Ã§Â¡Â®Ã¤Â¿Ã¥ËœÃ©â€¡Ã©â€¡Å’Ã¥Å’â€¦Ã?winsock Ã§â€ºÂ¸Ã¥â€¦Â³Ã¥Âºâ€œÃ¯Â¼Ë†Ã¥Â³Ã¤Â¾Â¿Ã©â€œÂ¾Ã¦Å½Â¥Ã¥â€˜Â½Ã¤Â»Â¤Ã¤Â¸Ã¦ËœÂ¾Ã¥Â¼Ã¥â€¡ÂºÃ?libevent/hiredis Ã¥Â­â€”Ã¦Â Â·Ã¤Â¹Å¸Ã¨Æ’Â½Ã§â€Å¸Ã¦â€¢Ë†Ã?
                if "-lws2_32" not in new:
                    out_lines = []
                    for line in new.splitlines(True):
                        if line.startswith(("LIBS", "LDLIBS")) and ("=" in line) and ("-lws2_32" not in line):
                            out_lines.append(line.rstrip("\n") + extra_libs + "\n")
                            made_changes = True
                            continue
                        out_lines.append(line)
                    new = "".join(out_lines)

                # Ã©ËœÂ²Ã¦Â­Â¢Ã¨Â¢Â«Ã¥Â½â€œÃ?exe Ã©â€œÂ¾Ã¦Å½Â¥Ã¥Â¯Â¼Ã¨â€?WinMainÃ¯Â¼Å¡Ã¤Â¼ËœÃ¥â€¦Ë†Ã¤Â»Å½Ã¥ËœÃ©â€¡Ã¥Â±â€šÃ©Â¢Ã?-shared
                if "redistimeseries.so" in new and "-shared" not in new:
                    out_lines = []
                    injected = False
                    for line in new.splitlines(True):
                        if not injected and line.startswith("LDFLAGS") and ("=" in line) and ("-shared" not in line):
                            out_lines.append(line.rstrip("\n") + " -shared\n")
                            injected = True
                            made_changes = True
                            continue
                        out_lines.append(line)
                    new = "".join(out_lines)

                if new != text:
                    path.write_text(new, encoding="utf-8")
                    made_changes = True

            if made_changes:
                print("patched generated makefiles under bin/")
            PY

            set +e
            "$MAKE_BIN" DISABLE_WERRORS=1 -j"$JOBS" V=1 VERBOSE=1 \
              "CONFIGURE_FLAGS.windows=--disable-samples --disable-libevent-regress --disable-openssl" \
              >> "$LOG" 2>&1
            STATUS="$?"
            set -e
          fi

          echo "make exit code: ${STATUS}"
          if [ "${STATUS}" -ne 0 ]; then
            echo "---- build log tail (last 200 lines) ----"
            tail -n 200 "$LOG" || true
            exit "${STATUS}"
          fi

      - name: Upload build log (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-windows-log
          path: redistimeseries-src/build-windows.log
          retention-days: 14

      - name: Package artifact
        run: |
          set -euo pipefail
          DIST="dist/RedisTimeSeries-${{ steps.vars.outputs.version }}-Windows-x64"
          mkdir -p "$DIST"

          TS_MOD="$(cd redistimeseries-src && find bin -maxdepth 6 -type f \( -name 'redistimeseries*.so' -o -name 'redistimeseries*.dll' \) | head -n 1)"
          if [ -z "$TS_MOD" ]; then
            echo "ERROR: module binary not found under redistimeseries-src/bin"
            exit 1
          fi

          # Provide both extensions for convenience.
          cp "$TS_MOD" "$DIST/redistimeseries.so"
          cp "$TS_MOD" "$DIST/redistimeseries.dll"

          # Copy common runtime DLLs (ignore if missing).
          cp /mingw64/bin/libgcc_s_seh-1.dll "$DIST/" || true
          cp /mingw64/bin/libstdc++-6.dll "$DIST/" || true
          cp /mingw64/bin/libwinpthread-1.dll "$DIST/" || true
          cp /mingw64/bin/libcrypto-3-x64.dll "$DIST/" || true
          cp /mingw64/bin/libssl-3-x64.dll "$DIST/" || true

          (cd dist && 7z a -tzip "RedisTimeSeries-${{ steps.vars.outputs.version }}-Windows-x64.zip" "RedisTimeSeries-${{ steps.vars.outputs.version }}-Windows-x64")

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: redistimeseries-windows
          path: dist/*.zip
          retention-days: 14
